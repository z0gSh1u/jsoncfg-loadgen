/**
 * https://github.com/z0gSh1u/jsoncfg-loadgen
 */

function raise(err) {
  throw new Error(err)
}

function getBasicType(v) {
  const type = typeof v
  if (type == 'object' || type == 'bigint' || type == 'function') {
    raise('Not basic type.')
  }
  if (type == 'number') {
    return ['float', 'int'][+(Math.floor(v) == v)]
  }
  return type
}

function collect(content) {
  const obj = JSON.parse(content)
  let kv = {}

  for (const key in obj) {
    const value = obj[key]
    const type = typeof value
    if (type == 'object') {
      if (Array.isArray(value)) {
        kv[key] = `Array ${getBasicType(value[0])}`
      } else {
        raise('Unsupported nested object.')
      }
    } else {
      kv[key] = getBasicType(value)
    }
  }

  return kv
}

function genPythonStyle(kv) {
  let decl = '# Python Style Generated by jsoncfg-loadgen\n'
  let stub = 'def loadConfig(cfgPath):'
  let globals = '  global'
  let load = ''
  load += `
  with open(cfgPath, 'r') as fp:
    cfg = json.load(fp)
  \n`
  for (const key in kv) {
    decl += `${key} = None\n`
    globals += ` ${key},`
    load += `  ${key} = cfg['${key}']\n`
  }
  globals = globals.substring(0, globals.length - 1)
  return decl + '\n' + stub + '\n' + globals + '\n' + load
}

function genCppRapidJSONStyle(kv) {
  function getTypeCpp(k, v) {
    if (v.startsWith('Array')) {
      const elementType = v.split(' ')[1]
      return {
        type: `std::vector<${elementType}>`,
        get: `rapidjsonArrayToVector<${elementType}>(d["${k}"].GetArray());`,
      }
    } else if (v == 'string') {
      return { type: 'std::string', get: `d["${k}"].GetString()` }
    } else if (v == 'boolean') {
      return { type: 'bool', get: `d["${k}"].GetBool()` }
    } else if (v == 'int') {
      return { type: 'int', get: `d["${k}"].GetInt()` }
    } else if (v == 'float') {
      return { type: 'float', get: `d["${k}"].GetFloat()` }
    }
    raise('Not basic type.')
  }

  let decl = '/* Cpp RapidJSON Style Generated by jsoncfg-loadgen */\n'
  let stub = `
template <typename T>
std::vector<T> rapidjsonArrayToVector(const rapidjson::GenericArray<false, rapidjson::Value> &arr) {
  std::vector<T> res;
  for (auto &&i = arr.Begin(); i != arr.End(); i++) {
    res.emplace_back(i->Get<T>());
  }
  return res;
}

void loadConfig(std::string cfgPath) {
  // TODO Please manage to read cfgPath as "std::string content".`

  let load = ''
  load += `
  rapidjson::Document d;
  d.Parse(content.c_str());
`
  for (const key in kv) {
    const v = kv[key]
    const { type, get } = getTypeCpp(key, v)
    decl += `${type} ${key};\n`
    load += `  ${key} = ${get};\n`
  }
  return decl + '\n' + stub + '\n' + load + '}\n'
}

;(function () {
  const jsonContent = ace.edit('jsonContent')
  jsonContent.session.setMode('ace/mode/json')
  const cfgLoader = ace.edit('cfgLoader')
  const errorDOM = document.getElementById('error')

  document.getElementById('pythonstylebtn').addEventListener('click', () => {
    try {
      const content = genPythonStyle(collect(jsonContent.getValue()))
      cfgLoader.session.setMode('ace/mode/python')
      cfgLoader.setValue(content)
    } catch (e) {
      errorDOM.innerText = String(e)
    }
  })

  document
    .getElementById('cpprapidjsonstylebtn')
    .addEventListener('click', () => {
      try {
        const content = genCppRapidJSONStyle(collect(jsonContent.getValue()))
        cfgLoader.session.setMode('ace/mode/c_cpp')
        cfgLoader.setValue(content)
      } catch (e) {
        errorDOM.innerText = String(e)
        throw e
      }
    })
})()
